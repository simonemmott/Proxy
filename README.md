# Proxy 0.1.0
The Proxy project provides a mechanism to dynamically generate proxy classes for any given class.  The public methods of the class
and all its sub classes are overridden on the proxy by calls to implementations of the java reflection `InvocationHandler` interface.

The invocation handler may, if so implemented pass invocations to an instance of the proxied class or handle the invocataion in any other way.

This project provides functionality similar to the java `Proxy` class without but for Classes rather than Interfaces.

Javadoc documentation of this project can be found [here](https://simonemmott.github.io/Proxy/index.html)

### License

[GNU GENERAL PUBLIC LICENSE v3](http://fsf.org/)

## Basic Example
The java below
```
Foo foo = new Foo();

Foo proxy = ProxyFactory.staticFactory().getProxy(Foo.class, new FooMethodHandler(foo));
```

Creates a proxy of Type `Foo.class` whose public methods as defined by the class Foo and its super classes will be handled by the 
`FooMethodHandler` being an implementation of the `InvocationHandler` interface from java reflection.

## Getting Started

Download a jar file containing the latest version or fork this project and install in your IDE

Maven users can add this project using the following additions to the pom.xml file.
```maven
<dependencies>
    ...
    <dependency>
        <groupId>com.k2</groupId>
        <artifactId>Proxy</artifactId>
        <version>0.1.0</version>
    </dependency>
    ...
</dependencies>
```

## Working With Proxy Classes

Java provides an API `Proxy` for dynamically generating implementations of a given Interface or Interfaces, however no similar support 
exists for creating proxies to Classes.

In this project such proxies are referred to as Proxy Classes or Proxy Instances.

Proxy Classes extend the class for which they are a proxy and implement the AProxy interface.  Each public method of the proxied class and its sub classes are implemented on the Proxy Class to override the methods on the proxied class. The override methods execute the invoke method of the invocation handler associated with the proxy instance. Consequently the invocation handlers that can be used with the proxy classes can also be used with the java `Proxy` API. 

Proxied classes must have a zero argument constructor and cannot be final in order to be proxied.

The AProxy interface requires the following methods:

| Method                                    | Description |
|===========================================|=============|
| `setInvocationHandler(InvocationHandler)` | Set the invocation handler that will be used by this proxy instance |
| `proxyForClass()`                         | Return the class that for which this is a proxy |

An instance of ProxyFactory is required  to create proxies. The ProxyFactory provodes the following static methods for creating instances of ProxyFactory.

| Method                            | Description |
|===================================|=============|
| `dynamicFactory(ProformaLibrary)` | Create an ProxyFactory that will generate its proxies using the given proforma library |
| `staticFactory()`                 | Return the shared static proxy factory that generates its proxies using the default proforma library |

There are several ways of generating Proxy instances using the ProxyFactory. The ProxyFactory provides the following methods for creating proxy classes and proxies.

| Method | Description |
|========|=============|
| `getProxy(Class, InvocationHandler)`                 | Create a proxy of the given class using the given InvocationHandler to handle invocations of the public methods of the proxied class |
| `getProxy(Object, Class<TypedInvocationHandler>...)` | Create a proxy of the given Object using the given array of invocation handler classes. If the array of handlers is empty then the given object is returned. The first class in the array must implement the `TargetedInvocationHandler` interface and will have the given object set as its target. Subsequent invocation handlers are created for each typed invocation handler class and they are chained together as appropriate for their type. |
| `getProxyClass(Class)`                               | Get the proxy class for the given class |

The example below shows creating a proxy for a known class using an existing invocation handler. The invocation handler can be any implementation of the java reflection `InvocationHandler` interface:

```java
Foo foo = new Foo();

InvocationHander handler = new FooInvocationHandler(foo); 

ProxyFactory proxyFactory = ProxtFactory.staticFactory();

Foo proxy = proxtFactory.getProxy(Foo.class, handler);
```

The `proxy` for the class `Foo` generated by the call to `getProxy(...)` is a `Foo` and can be used anywhere that a Foo could be used however all calls the the public methods of the proxy will be handled by the InvocationHandler for the appropriate method of the Foo class.

The example below shows creating a proxy for an object specifying a list of handlers to handle invocations of the proxies methods, eventually calling 
the proxied method of the object if the first invocation handler class is designed to do so.

```java
Foo foo = new Foo();

ProxyFactory proxyFactory = ProxyFactory.staticFactory();

Foo proxy = proxyFactory.getProxy(foo, FooInvocationHandler.class, OtherInvocationHandler.class, OuterHandler.class);
```

The `proxy` created by the call to `getProxy(...)` is a `Foo` and can be used anywhere that a Foo could be used however all the calls to the public
methods of the proxy will be handled by instances of the TypedInvocationHandlers. The order in which the handlers handle the request last to first.

In the above example the handler created for the OuterHandler.class will be invoked first. If this handler also invokes it's target or linked handler then the OtherInvocationHandler instance is called to also handle the invocation as called by the OuterHandler instance. Finally the FooInvocationHandler instance is called if the OtherInvocationHandler call its target of linked handler. The FooInvocationHandler must be an implementation of `TargetedInvocationHandler` and its target is set to the given foo instance. If the `FooInvocationHandler` calls the method on its target then the method on the foo instance is called.

This approach allows several invocation handlers to be registered with a single proxy instance and for their invoke methods to be chained together.

The example below shows creating a proxy through the generation of the proxy class and explicitly creating an instance of the proxy and programatically setting the invocation handler.

```java
Foo foo = new Foo();

InvocationHander handler = new FooInvocationHandler(foo); 

ProxyFactory proxyFactory = ProxyFactory.staticFactory();

Class<AProxy<Foo>> proxyClass = proxyFactory.getProxyClass(Foo.class);

AProxy<Foo> aProxy = proxyClass.newInstance();

aProxy.setInvocationHandler(handler);

Foo proxy = (Foo)aProxy;
```

The proxy is a `Foo` an can be used anywhere that a `Foo` could be used except that all calls to the public methods of `Foo` or its super classes
will be handled by the invoke method of the handler object.

The class returned by the call to `getProxtClass(...)` extends the given `Foo.class` and implements the `AProxy` interface.
If the given class already implements the `AProxy` interface then the given class is returned as the proxy class. A proxy class is generated for the given class and returned unless the proxy has already been generated for the given class, in which case the previously generated class is returned.









